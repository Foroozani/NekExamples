c- CASE PARAMETERS------------------------------------------------------

#define tSTATSTART uparam(1) /* start time for averaging */
#define tSTATFREQ  uparam(2) /* output frequency for statistics */

c data extraction along wall normal direction
#define INTP_NMAX 100 /* number of sample points */
#define BETAI 2.4     /* sample points stretching parameter */
#define XCINT 1.0     /* x coordinate */
#define ZCINT 1.0     /* z coordinate */

c mesh dimensions
#define PI (4.*atan(1.))
#define DELTA 1.
#define XLEN (2.*PI)
#define YLEN (2*DELTA)
#define ZLEN PI
#define NUMBER_ELEMENTS_X 16
#define NUMBER_ELEMENTS_Y 12
#define NUMBER_ELEMENTS_Z 8

c- INCLUDES ------------------------------------------------------------
#include "intp_usr.f"
c-----------------------------------------------------------------------

      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      udiff  = 1.
      utrans = 1.

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0 
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'  ! for nelx,nely,nelz

      real x0(3)
      data x0 /0.0, 0.0, 0.0/ 
      save x0

      integer icalld
      save    icalld
      data    icalld /0/

      real atime,timel
      save atime,timel

      integer ntdump
      save    ntdump

      integer nint
      save    nint

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      save igs_x, igs_z

      parameter(nstat=5)
      real ravg(lx1*ly1*lz1*lelt,nstat)
      real stat(lx1*ly1*lz1*lelt,nstat)
      real stat_y(INTP_NMAX*nstat)
      common /dstat/ ravg, stat, stat_y

      common /ctorq/ dragx(0:maxobj),dragpx(0:maxobj),dragvx(0:maxobj)
     $             , dragy(0:maxobj),dragpy(0:maxobj),dragvy(0:maxobj)
     $             , dragz(0:maxobj),dragpz(0:maxobj),dragvz(0:maxobj)
c
     $             , torqx(0:maxobj),torqpx(0:maxobj),torqvx(0:maxobj)
     $             , torqy(0:maxobj),torqpy(0:maxobj),torqvy(0:maxobj)
     $             , torqz(0:maxobj),torqpz(0:maxobj),torqvz(0:maxobj)
c
     $             , dpdx_mean,dpdy_mean,dpdz_mean
     $             , dgtq(3,4)

      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      real tplus

      n     = nx1*ny1*nz1*nelv
      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z

      if (istep.eq.0) then
         if (nelx.gt.lelx .or. nely.gt.lely .or. nelz.gt.lelz)
     $       call exitti('nel_xyz > lel_xyz!$',1)
         call set_obj
      endif

      ubar = glsc2(vx,bm1,n)/volvm1
      e2   = glsc3(vy,bm1,vy,n)+glsc3(vz,bm1,vz,n)
      e2   = e2/volvm1
      if(nid.eq.0) write(6,2) time,ubar,e2
   2               format(1p3e13.4,' monitor')

      if (time.lt.tSTATSTART) return

c
c     What follows computes some statistics ...
c

      if(ifoutfld) then
        if(ldimt.ge.2) call lambda2(t(1,1,1,1,2))
        if(ldimt.ge.5) call comp_vort3(t(1,1,1,1,3),wo1,wo2,vx,vy,vz)
      endif

      call torque_calc(1.0,x0,.false.,.false.) ! compute wall shear

      if(icalld.eq.0) then
        if(nid.eq.0) write(6,*) 'Start collecting statistics ...'

        nxm = 2 ! linear mesh
        call intp_setup(0.0,nxm)
        nint = 0
        if (nid.eq.0) then
          nint = INTP_NMAX
          call cfill(xint,XCINT,size(xint))
          do i = 1,INTP_NMAX 
             yi = (i-1.)/(INTP_NMAX-1)
             yint(i) = tanh(BETAI*(2*yi-1))/tanh(BETAI)
          enddo
          call cfill(zint,ZCINT,size(zint))
        endif
        call intp_nfld(stat_y,ravg,1,xint,yint,zint,nint,.true.)

        call gtpp_gs_setup(igs_x,nelx     ,nely,nelz,1) ! x-avx
        call gtpp_gs_setup(igs_z,nelx*nely,1   ,nelz,3) ! z-avg

        call rzero(ravg,size(ravg))
        dragx_avg = 0
        atime     = 0
        timel     = time
        ntdump    = int(time/tSTATFREQ)

        icalld = 1
      endif

      dtime = time - timel
      atime = atime + dtime

      ! averaging over time
      if (atime.ne.0. .and. dtime.ne.0.) then
        beta      = dtime / atime
        alpha     = 1. - beta
        ifverbose = .false.

        call avg1(ravg(1,1),vx   ,alpha,beta,n,'uavg',ifverbose)
        call avg2(ravg(1,2),vx   ,alpha,beta,n,'urms',ifverbose)
        call avg2(ravg(1,3),vy   ,alpha,beta,n,'vrms',ifverbose)
        call avg2(ravg(1,4),vz   ,alpha,beta,n,'wrms',ifverbose)
        call avg3(ravg(1,5),vx,vy,alpha,beta,n,'uvmm',ifverbose)
        dragx_avg = alpha*dragx_avg + beta*0.5*(dragx(1)+dragx(2))
      endif

      ! write statistics to file
      if(istep.gt.0 .and. time.gt.(ntdump+1)*tSTATFREQ) then
         ! averaging over statistical homogeneous directions (x-z)
         do i = 1,nstat
            call planar_avg(wo1      ,ravg(1,i),igs_x)
            call planar_avg(stat(1,i),wo1      ,igs_z)
         enddo

c         call outpost(wo1,stat(1,1),ravg(1,1),t,t,'sta')
  
         ! extract data along wall normal direction (1D profile)
         call intp_nfld(stat_y,stat,nstat,xint,yint,zint,nint,.false.)

         if (nid.ne.0) goto 998 

         rho    = param(1)
         dnu    = param(2)
         A_w    = XLEN * ZLEN
         tw     = dragx_avg / A_w
         u_tau  = sqrt(tw / rho)
         Re_tau = u_tau * DELTA / dnu
         tplus  = time * Re_tau * u_tau

         write(6,*) 'Dumping statistics ...', tplus, Re_tau
 
         open(unit=56,file='vel_fluc_prof.dat')
         write(56,'(A,1pe14.7)') '#time = ', time
         write(56,'(A)') '#  y     y+     uu     vv     ww     uv'

         open(unit=57,file='mean_prof.dat')
         write(57,'(A,1pe14.7)') '#time = ', time
         write(57,'(A)') '#  y     y+    Umean'

         do i = 1,nint
            write(56,3) 
     &           yint(i),
     &           yint(i)*Re_tau,
     &           (stat_y(1*nint+i)-(stat_y(0*nint+i))**2)/u_tau**2,
     &           stat_y(2*nint+i)/u_tau**2,
     &           stat_y(3*nint+i)/u_tau**2,
     &           stat_y(4*nint+i)/u_tau**2

            write(57,3) 
     &           yint(i),
     &           yint(i)*Re_tau, 
     &           stat_y(0*nint+i)/u_tau

  3         format(1p15e17.9)
         enddo
         close(56)
         close(57)

         ntdump = ntdump + 1
 998  endif

      timel = time

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg) ! just called for the walls
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux = 0.0
      uy = 0.0
      uz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer idum
      save    idum 
      data    idum / 0 /

      real C, k, kx, ky

      Re_tau = 550 
      C      = 5.17
      k      = 0.41

      yp = (1-y)*Re_tau
      if (y.lt.0) yp = (1+y)*Re_tau
      
      ! Reichardt function
      ux  = 1/k*log(1+k*yp) + (C - (1/k)*log(k)) *
     $      (1 - exp(-yp/11) - yp/11*exp(-yp/3))
      ux  = ux * Re_tau*param(2)

      eps = 1e-2
      kx  = 23
      kz  = 13

      alpha = kx * 2*PI/XLEN
      beta  = kz * 2*PI/ZLEN 

      ! add perturbation to trigger turbulence 
      ux  = ux  + eps*beta  * sin(alpha*x)*cos(beta*z) 
      uy  =       eps       * sin(alpha*x)*sin(beta*z)
      uz  =      -eps*alpha * cos(alpha*x)*sin(beta*z)

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'      ! _before_ mesh is generated, which 
      include 'TOTAL'     ! guarantees GLL mapping of mesh.

      n = nelv * 2**ldim
      xmin = glmin(xc,n)
      xmax = glmax(xc,n)
      ymin = glmin(yc,n)
      ymax = glmax(yc,n)
      zmin = glmin(zc,n)
      zmax = glmax(zc,n)

      xscale = XLEN/(xmax-xmin)
      yscale = YLEN/(ymax-ymin)
      zscale = ZLEN/(zmax-zmin)

      do i=1,n
         xc(i,1) = xscale*xc(i,1)
         yc(i,1) = yscale*yc(i,1)
         zc(i,1) = zscale*zc(i,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2   ! This routine to modify mesh coordinates
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      param(54) = -1  ! use >0 for const flowrate or <0 bulk vel
                      ! flow direction is given by (1=x, 2=y, 3=z) 
      param(55) = 1.0 ! flowrate/bulk-velocity 

      return
      end
c-----------------------------------------------------------------------
      subroutine set_obj  ! define objects for surface integrals

      include 'SIZE'
      include 'TOTAL'

      integer e,f

      nobj = 2			! for Periodic
      iobj = 0
      do ii=nhis+1,nhis+nobj
         iobj = iobj+1
         hcode(10,ii) = 'I'
         hcode( 1,ii) = 'F' ! 'F'
         hcode( 2,ii) = 'F' ! 'F'
         hcode( 3,ii) = 'F' ! 'F'
         lochis(1,ii) = iobj
      enddo
      nhis = nhis + nobj

      if (maxobj.lt.nobj) write(6,*) 'increase maxobj in SIZE'
      if (maxobj.lt.nobj) call exitt

      nxyz = nx1*ny1*nz1
      do e=1,nelv
      do f=1,2*ndim
         if (cbc(f,e,1).eq.'W  ') then
            iobj = 0
            if (f.eq.1) iobj=1  ! lower wall
            if (f.eq.3) iobj=2  ! upper wall
            if (iobj.gt.0) then
               nmember(iobj) = nmember(iobj) + 1
               mem = nmember(iobj)
               ieg = lglel(e)
               object(iobj,mem,1) = ieg
               object(iobj,mem,2) = f
c              write(6,1) iobj,mem,f,ieg,e,nid,' OBJ'
    1          format(6i9,a4)
            endif
         endif
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine planar_avg(ua,u,hndl)
c
c     Note: This works only for global tensor product or extruded meshes 
c
      include 'SIZE'
      include 'TOTAL'

      real ua(lx1,ly1,lz1,lelv)
      real u (lx1,ly1,lz1,lelv)

      common /scrcg/ wrk(lx1,ly1,lz1,lelv)

      n = nx1*ny1*nz1*nelv

      call copy(wrk,bm1,n)              ! Set the averaging weights
      call fgslib_gs_op(hndl,wrk,1,1,0) ! Sum weights
      call invcol1(wrk,n)

      do i=1,n
         ua(i,1,1,1) = u(i,1,1,1) ! bm1(i,1,1,1)*u(i,1,1,1)*wrk(i,1,1,1)
      enddo

      call fgslib_gs_op(hndl,ua,1,1,0) ! Sum weighted values

      return
      end
