c- description ---------------------------------------------------------
c  
c  Turbulent channel flow
c
c-----------------------------------------------------------------------

c- global includes -----------------------------------------------------
c#include "experimental/avs.f"
c-----------------------------------------------------------------------

c- constants -----------------------------------------------------------

#define tSTATSTART uparam(1) /* start time for averaging */
#define tSTATFREQ  uparam(2) /* output frequency for statistics */

c data extraction along wall normal direction
#define INTP_NMAX 100 /* number of sample points */
#define BETAI 2.4     /* sample points stretching parameter */
#define XCINT 1.0     /* x coordinate of 1D line*/
#define ZCINT 1.0     /* z coordinate of 1D line */

c mesh dimensions
#define PI (4.*atan(1.))
#define DELTA 1.
#define XLEN (2.*PI)
#define YLEN (2*DELTA)
#define ZLEN PI
#define NUMBER_ELEMENTS_X 16
#define NUMBER_ELEMENTS_Y 12
#define NUMBER_ELEMENTS_Z 8

c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e
      parameter (avs_c    = 0.5)
      parameter (avs_cmax = 0.1)
      parameter (ncut     = 2)

      utrans = 1.
      udiff  = param(2)

      if (ifield .eq. 2) then
         e = gllel(ieg)
         udiff = param(8)
         udiff_a = avs_vdiff(ix,iy,iz,e,ifield,avs_c,avs_cmax,ncut)
         udiff = udiff + udiff_a
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0 
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol =  0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      real x0(3)
      data x0 /0.0, 0.0, 0.0/ 
      save x0

      integer icalld
      save    icalld
      data    icalld /0/

      real atime,timel
      save atime,timel

      integer ntdump
      save    ntdump

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h
      save    nint, intp_h

      logical iffpts
      save iffpts

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      save igs_x, igs_z

      parameter(nstat=9)
      real ravg(lx1*ly1*lz1*lelt,nstat)
      real stat(lx1*ly1*lz1*lelt,nstat)
      real stat_y(INTP_NMAX*nstat)
      save ravg, stat, stat_y

      common /ctorq/ dragx(0:maxobj),dragpx(0:maxobj),dragvx(0:maxobj)
     $             , dragy(0:maxobj),dragpy(0:maxobj),dragvy(0:maxobj)
     $             , dragz(0:maxobj),dragpz(0:maxobj),dragvz(0:maxobj)

     $             , torqx(0:maxobj),torqpx(0:maxobj),torqvx(0:maxobj)
     $             , torqy(0:maxobj),torqpy(0:maxobj),torqvy(0:maxobj)
     $             , torqz(0:maxobj),torqpz(0:maxobj),torqvz(0:maxobj)

     $             , dpdx_mean,dpdy_mean,dpdz_mean
     $             , dgtq(3,4)

      save dragx_avg

      logical ifverbose
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)

      real tplus
      real tmn, tmx

      n     = nx1*ny1*nz1*nelv
      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z

      if (istep.eq.0) then
         call set_obj
         call prepost(.true.,'  ')
      endif

      ubar = glsc2(vx,bm1,n)/volvm1
      e2   = glsc3(vy,bm1,vy,n)+glsc3(vz,bm1,vz,n)
      e2   = e2/volvm1
      tmn  = glmin(t,n)
      tmx  = glmax(t,n)
      if(nid.eq.0) write(6,2) time,ubar,e2,tmn,tmx
   2               format(1p5e13.4,' monitor')

      if (time.lt.tSTATSTART) return

c
c     What follows computes some statistics ...
c

c      if(ifoutfld) then
c        if (ldimt.ge.2) call lambda2(t(1,1,1,1,2))
c        if (ldimt.ge.3) call comp_vort3(t(1,1,1,1,3),wo1,wo2,vx,vy,vz)
c      endif

      if(icalld.eq.0) then
        if(nid.eq.0) write(6,*) 'Start collecting statistics ...'

        nxm = 2 ! mesh is linear
        call intp_setup(0.0,nxm,intp_h)
        nint = 0
        if (nid.eq.0) then
          nint = INTP_NMAX
          call cfill(xint,XCINT,size(xint))
          do i = 1,INTP_NMAX 
             yi = (i-1.)/(INTP_NMAX-1)
             yint(i) = tanh(BETAI*(2*yi-1))/tanh(BETAI)
          enddo
          call cfill(zint,ZCINT,size(zint))
        endif
        iffpts = .true. ! dummy call to find points
        call intp_nfld(stat_y,ravg,1,xint,yint,zint,nint,
     $                 iwk,rwk,INTP_NMAX,iffpts,intp_h)
        iffpts = .false.
        call gtpp_gs_setup(igs_x,nelx     ,nely,nelz,1) ! x-avx
        call gtpp_gs_setup(igs_z,nelx*nely,1   ,nelz,3) ! z-avg

        call rzero(ravg,size(ravg))
        dragx_avg = 0
        atime     = 0
        timel     = time
        ntdump    = int(time/tSTATFREQ)

        icalld = 1
      endif

      dtime = time - timel
      atime = atime + dtime

      ! averaging over time
      if (atime.ne.0. .and. dtime.ne.0.) then
        beta      = dtime / atime
        alpha     = 1. - beta

        ifverbose = .false.
        call avg1(ravg(1,1),vx   ,alpha,beta,n,'uavg',ifverbose)
        call avg2(ravg(1,2),vx   ,alpha,beta,n,'urms',ifverbose)
        call avg2(ravg(1,3),vy   ,alpha,beta,n,'vrms',ifverbose)
        call avg2(ravg(1,4),vz   ,alpha,beta,n,'wrms',ifverbose)
        call avg3(ravg(1,5),vx,vy,alpha,beta,n,'uvmm',ifverbose)

        call avg1(ravg(1,6),t    ,alpha,beta,n,'tavg',ifverbose)
        call avg2(ravg(1,7),t    ,alpha,beta,n,'trms',ifverbose)
        call avg3(ravg(1,8),vx,t ,alpha,beta,n,'utmm',ifverbose)
        call avg3(ravg(1,9),vy,t ,alpha,beta,n,'vtmm',ifverbose)

        call torque_calc(1.0,x0,.false.,.false.) ! compute wall shear
        dragx_avg = alpha*dragx_avg + beta*0.5*(dragx(1)+dragx(2))
      endif

      timel = time

      ! write statistics to file
      if(istep.gt.0 .and. time.gt.(ntdump+1)*tSTATFREQ) then
         ! averaging over statistical homogeneous directions (x-z)
         do i = 1,nstat
            call planar_avg(wo1      ,ravg(1,i),igs_x)
            call planar_avg(stat(1,i),wo1      ,igs_z)
         enddo

         ! evaluate d<T>/dy at the lower wall
         call opgrad(wo1,wo2,wo3,stat(1,6))
         call dssum(wo2,lx1,ly1,lz1)
         call col2(wo2,binvm1,n)
         call intp_nfld(stat_y,wo2,1,xint,yint,zint,nint,
     $                  iwk,rwk,INTP_NMAX,iffpts,intp_h)
         dTdy_w = stat_y(1)

         ! extract data along wall normal direction (1D profile)
         call intp_nfld(stat_y,stat,nstat,xint,yint,zint,nint,
     $                  iwk,rwk,INTP_NMAX,iffpts,intp_h)

         ntdump = ntdump + 1
         if (nid.ne.0) goto 998 

         rho    = param(1)
         dnu    = param(2)
         A_w    = XLEN * ZLEN
         tw     = dragx_avg / A_w
         u_tau  = sqrt(tw / rho)
         qw     = -param(8) * dTdy_w
         t_tau  = 1/u_tau * qw
         Re_tau = u_tau * DELTA / dnu
         tplus  = time * u_tau**2 / dnu

         write(6,*) 'Dumping statistics ...', Re_tau, t_tau
 
         open(unit=56,file='vel_fluc_prof.dat')
         write(56,'(A,1pe14.7)') '#time = ', time
         write(56,'(A)') 
     $    '#  y    y+    uu    vv    ww    uv    tt    ut    -vt'

         open(unit=57,file='mean_prof.dat')
         write(57,'(A,1pe14.7)') '#time = ', time
         write(57,'(A)') 
     $    '#  y    y+    Umean    Tmean'

         do i = 1,nint
            yy = 1+yint(i)
            write(56,3) 
     &           yy,
     &           yy*Re_tau,
     &           (stat_y(1*nint+i)-(stat_y(0*nint+i))**2)/u_tau**2,
     &           stat_y(2*nint+i)/u_tau**2,
     &           stat_y(3*nint+i)/u_tau**2,
     &           stat_y(4*nint+i)/u_tau**2,
     &           (stat_y(6*nint+i)-(stat_y(5*nint+i))**2)/t_tau**2,
     &           stat_y(7*nint+i)/qw,
     &           -stat_y(8*nint+i)/qw

            write(57,3) 
     &           yy,
     &           yy*Re_tau, 
     &           stat_y(0*nint+i)/u_tau,
     &           stat_y(5*nint+i)/t_tau

  3         format(1p15e17.9)
         enddo
         close(56)
         close(57)

 998  endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      if (y.lt.0) temp = 1.0
      if (y.gt.0) temp = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer idum
      save    idum 
      data    idum / 0 /

      real C, k, kx, ky

      Re_tau = 550 
      C      = 5.17
      k      = 0.41

      yp = (1-y)*Re_tau
      if (y.lt.0) yp = (1+y)*Re_tau
      
      ! Reichardt function
      ux  = 1/k*log(1+k*yp) + (C - (1/k)*log(k)) *
     $      (1 - exp(-yp/11) - yp/11*exp(-yp/3))
      ux  = ux * Re_tau*param(2)

      eps = 1e-2
      kx  = 23
      kz  = 13

      alpha = kx * 2*PI/XLEN
      beta  = kz * 2*PI/ZLEN 

      ! add perturbation to trigger turbulence 
      ux  = ux  + eps*beta  * sin(alpha*x)*cos(beta*z) 
      uy  =       eps       * sin(alpha*x)*sin(beta*z)
      uz  =      -eps*alpha * cos(alpha*x)*sin(beta*z)

      ! thin boundary layer at the lower wall
      gamma = 5e-6 ! initial thickness
      temp = erfc((1+y)/sqrt(1./param(8) * gamma))

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'      ! _before_ mesh is generated, which 
      include 'TOTAL'     ! guarantees GLL mapping of mesh.

      n = nelv * 2**ldim
      xmin = glmin(xc,n)
      xmax = glmax(xc,n)
      ymin = glmin(yc,n)
      ymax = glmax(yc,n)
      zmin = glmin(zc,n)
      zmax = glmax(zc,n)

      xscale = XLEN/(xmax-xmin)
      yscale = YLEN/(ymax-ymin)
      zscale = ZLEN/(zmax-zmin)

      do i=1,n
         xc(i,1) = xscale*xc(i,1)
         yc(i,1) = yscale*yc(i,1)
         zc(i,1) = zscale*zc(i,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2   ! This routine to modify mesh coordinates
      include 'SIZE'
      include 'TOTAL'

      do iel=1,nelt
      do ifc=1,2*ndim
         cbc(ifc,iel,2) = cbc(ifc,iel,1) 
         if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,2) = 't  '
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      param(54) = -1  ! use >0 for const flowrate or <0 bulk vel
                      ! flow direction is given by (1=x, 2=y, 3=z) 
      param(55) = 1.0 ! flowrate/bulk-velocity 

      iffilter(2) = .false. ! artificial visocity only

      return
      end
c-----------------------------------------------------------------------
      subroutine set_obj  ! define objects for surface integrals

      include 'SIZE'
      include 'TOTAL'

      integer e,f

      nobj = 2			! for Periodic
      iobj = 0
      do ii=nhis+1,nhis+nobj
         iobj = iobj+1
         hcode(10,ii) = 'I'
         hcode( 1,ii) = 'F' ! 'F'
         hcode( 2,ii) = 'F' ! 'F'
         hcode( 3,ii) = 'F' ! 'F'
         lochis(1,ii) = iobj
      enddo
      nhis = nhis + nobj

      if (maxobj.lt.nobj) write(6,*) 'increase maxobj in SIZE'
      if (maxobj.lt.nobj) call exitt

      nxyz = nx1*ny1*nz1
      do e=1,nelv
      do f=1,2*ndim
         if (cbc(f,e,1).eq.'W  ') then
            iobj = 0
            if (f.eq.1) iobj=1  ! lower wall
            if (f.eq.3) iobj=2  ! upper wall
            if (iobj.gt.0) then
               nmember(iobj) = nmember(iobj) + 1
               mem = nmember(iobj)
               ieg = lglel(e)
               object(iobj,mem,1) = ieg
               object(iobj,mem,2) = f
c              write(6,1) iobj,mem,f,ieg,e,nid,' OBJ'
    1          format(6i9,a4)
            endif
         endif
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine planar_avg(ua,u,hndl)
c
c     Note: This works only for global tensor product or extruded meshes 
c
      include 'SIZE'
      include 'TOTAL'

      real ua(lx1,ly1,lz1,lelv)
      real u (lx1,ly1,lz1,lelv)

      common /scrcg/ wrk(lx1,ly1,lz1,lelv)

      n = nx1*ny1*nz1*nelv

      call copy(wrk,bm1,n)              ! Set the averaging weights
      call fgslib_gs_op(hndl,wrk,1,1,0) ! Sum weights
      call invcol1(wrk,n)

      do i=1,n
         ua(i,1,1,1) = bm1(i,1,1,1)*u(i,1,1,1)*wrk(i,1,1,1)
      enddo

      call fgslib_gs_op(hndl,ua,1,1,0) ! Sum weighted values

      return
      end
